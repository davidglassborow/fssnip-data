// http://www.fssnip.net/7WX
// https://math.stackexchange.com/questions/3337570/
//         the-kth-derivative-of-sinn-x-as-n-sinn-k-x-times-a-polynomial-in/

namespace Adhemar.Polynomials

open System
open System.Diagnostics.Contracts
open System.Numerics
open System.Text

module Complex =

    let ofFloat64 f =
        Complex (f, 0.0)

    let ofInt32 n =
        ofFloat64 (float n)

    let ofUInt32 (n : uint32) =
        ofFloat64 (float n)

    let ofInt64 (n : int64) =
        ofFloat64 (float n)

module IntegerMath =

    let powerOfMinusOne p =
        if p % 2 = 0 then
            1
        else
            -1

    let rec power n p =
        if p = 0u then
            1
        else
            n * power n (p - 1u)

    let rec factorial n =
        if n = 0u then
            1u
        else
            n * factorial (n - 1u)

    let choose n m =
        if m > n then
            0u
        else
            factorial n / (factorial m * factorial (n - m))

type ICoefficient =

    // InvalidCastExceptions may occur when adding or multiplying with ICoefficients of different types
    // ArgumentExceptions may occur when adding or multiplying with incompatible ICoefficients

    abstract member Zero : ICoefficient
    abstract member IsOne : bool
    abstract member Add : ICoefficient -> ICoefficient
    abstract member Scale64 : int64 -> ICoefficient
    abstract member Multiply : ICoefficient -> ICoefficient
    abstract member IsNegative : bool
    abstract member CoefficientString : bool * bool -> string
    abstract member Apply : Map<string, float> -> float
    abstract member ApplyComplex : Map<string, Complex> -> Complex

type Coefficient64 (value : int64) =

    member __.Value =
        value

    static member Zero =
        Coefficient64 0L

    member __.IsOne =
        __.Value = 1L

    static member (+) (m : Coefficient64, n : Coefficient64) =
        Coefficient64 (m.Value + n.Value)

    static member (*) (scalingFactor : int64, m : Coefficient64) =
        Coefficient64 (scalingFactor * m.Value)

    static member (*) (m : Coefficient64, n : Coefficient64) =
        Coefficient64 (m.Value * n.Value)

    member __.IsNegative =
        __.Value < 0L

    static member (~-) (m : Coefficient64) =
        -1L * m

    override __.ToString () =
        sprintf "%d" __.Value

    member __.CoefficientString (first : bool, explicitOne : bool) =
        if explicitOne || (not __.IsOne && not (-__).IsOne) then
            if first then
                __.ToString ()
            elif __.IsNegative then
                sprintf " - %d" (-__).Value
            else
                sprintf " + %d" __.Value
        else
            if __.IsOne then
                if first then
                    String.Empty
                else
                    " + "
            else
                if first then
                    "-"
                else
                    " - "

    interface ICoefficient with
        member __.Zero =
            upcast Coefficient64.Zero
        member __.IsOne =
            __.IsOne
        member __.Add (t : ICoefficient) =
            upcast (__ + downcast t)
        member __.Scale64 (scalingFactor : int64) =
            upcast (scalingFactor * __)
        member __.Multiply (t : ICoefficient) =
            upcast (__ * downcast t)
        member __.IsNegative =
            __.IsNegative
        member __.CoefficientString (first : bool, explicitOne : bool) =
            __.CoefficientString (first, explicitOne)
        member __.Apply (_m : Map<string, float>) =
            float __.Value
        member __.ApplyComplex (m : Map<string, Complex>) =
            Complex.ofInt64 __.Value

    member __.IsZero =
        __ = Coefficient64.Zero

    static member (-) (m : Coefficient64, n : Coefficient64) =
        m + (-n)

    static member One =
        Coefficient64 1L

    static member MinusOne =
        -Coefficient64.One

    override __.GetHashCode () =
        __.Value.GetHashCode ()

    member __.Equals (that : Coefficient64) =
        __.Value = that.Value

    interface IEquatable<Coefficient64> with
        member __.Equals (that : Coefficient64) =
            __.Equals that

    override __.Equals (that : obj) =
        match that with
            | null ->
                false
            | :? Coefficient64 as thatCoefficient64 ->
                __.Equals thatCoefficient64
            | _ ->
                false

    static member op_Equality (r : Coefficient64, t : Coefficient64) =
        r.Equals t

    static member op_Inequality (r : Coefficient64, t : Coefficient64) =
        not (Coefficient64.op_Equality (r, t))

    static member op_Implicit (value : int64) =
        Coefficient64 value

type Polynomial<'T when 'T : equality and 'T :> ICoefficient>
        (x : string, ys : string list option,
            f : (string list option -> Map<string, float> -> float) option,
            g : (string list option -> Map<string, Complex> -> Complex) option,
            coefficients : 'T list) =

    static let isEmptyOrSingleton cs =
        match cs with
            | []
            | [_] ->
                true
            | _ ->
                false

    static let isZero (t : 'T) =
        let x = t :> ICoefficient
        x = x.Zero

    static let rec exactlyOneNonZero (cs : 'T list) =
        match cs with
            | [] ->
                None
            | [c] ->
                Some c
            | h :: ts ->
                if isZero h then
                    exactlyOneNonZero ts
                else
                    None

    static let rec add (cs, ds) =
        match cs, ds with
            | _, [] ->
                cs
            | [], _ ->
                ds
            | g :: ts, h :: rs ->
                downcast ((g :> ICoefficient).Add h) :: add (ts, rs)

    static let rec shiftRank k (cs : 'T list) =
        if k <= 0 then
            List.skip (-k) cs
        elif List.isEmpty cs then
            List.empty
        else
            downcast (List.head cs).Zero :: (shiftRank (k - 1) cs)

    static let rec hasOnlyEvenIndexedItems (cs : 'T list) =
        match cs with
            | [] ->
                true
            | h :: ts ->
                hasOnlyOddIndexedItems ts

    and hasOnlyOddIndexedItems (cs : 'T list) =
        match cs with
            | [] ->
                true
            | h :: ts ->
                isZero h && hasOnlyEvenIndexedItems ts

    do
        let rec nonZeroHighestCoefficient cs =
            match cs with
                | [] ->
                    true
                | [c] when isZero c ->
                    false
                | _ :: ts ->
                    nonZeroHighestCoefficient ts
        let isNoneOrAllAreNotEmpty zs =
            match zs with
                | None ->
                    true
                | Some bs ->
                    let isNeitherNullNorEmpty s =
                        not (String.IsNullOrEmpty s)
                    List.forall isNeitherNullNorEmpty bs
        let distinct v ws =
            let allDistinct mySequence =
                let folder state element =
                    match state with
                        | Some elementsSoFar when not (Set.contains element elementsSoFar) ->
                            Some (Set.add element elementsSoFar)
                        | _ ->
                            None
                let initialState = Some Set.empty
                let scanning = Seq.scan folder initialState mySequence
                Seq.forall Option.isSome scanning
            match ws with
                | None ->
                    true
                | Some zs ->
                    allDistinct (v :: zs)
        if isNull x then
            nullArg "x"
        elif not (nonZeroHighestCoefficient coefficients) then
            invalidArg "coefficients" "Zero highest coefficient"
        elif not (isNoneOrAllAreNotEmpty ys) then
            invalidArg "ys" "At least one empty y in ys"
        elif isEmptyOrSingleton coefficients && x <> String.Empty then
            invalidArg "x" "Non-empty variable x for constant Polynomial"
        elif isEmptyOrSingleton coefficients && Option.isSome ys then
            invalidArg "ys" "Some arguments ys for constant Polynomial"
        elif isEmptyOrSingleton coefficients && Option.isSome f then
            invalidArg "ys" "Some function f for constant Polynomial"
        elif not (isEmptyOrSingleton coefficients) && x = String.Empty then
            invalidArg "x" "Empty x for non-constant Polynomial"
        elif not (distinct x ys) then
            invalidArg "ys" ("Some duplicate argument y" +
                " or argument y with same name as variable function x")
        elif Option.isSome ys && Option.isNone f then
            invalidArg "f" "Some argument y but no function f"

    static member Create
            (x : string, ys : string list option,
                f : (string list option -> Map<string, float> -> float) option,
                g : (string list option -> Map<string, Complex> -> Complex) option,
                coefficients : 'T list) =
        let rec deZeroHighestCoefficient cs =
            match cs with
                | [] ->
                    List.empty
                | [c] when isZero c ->
                    List.empty
                | h :: ts ->
                    let deZeroTail = deZeroHighestCoefficient ts
                    if isZero h && List.isEmpty (deZeroHighestCoefficient ts) then
                        List.empty
                    else
                        h :: deZeroTail
        let deZeroCoefficients = deZeroHighestCoefficient coefficients
        if isEmptyOrSingleton deZeroCoefficients then
            Polynomial (String.Empty, None, None, None, deZeroCoefficients)
        else
            let emptyInsteadOfNull (s : string) =
                if isNull s then
                    String.Empty
                else
                    s
            Polynomial (emptyInsteadOfNull x, ys, f, g, coefficients)

    member __.X =
        x

    member __.Ys =
        ys

    member __.F =
        f

    member __.G =
        g

    member __.Coefficients =
        coefficients

    static member Zero =
        Polynomial (String.Empty, None, None, None, List.empty<'T>)

    member __.IsOne =
        match __.Coefficients with
            | [c] ->
                (c :> ICoefficient).IsOne
            | _ ->
                false

    member __.IsConstant =
        isEmptyOrSingleton __.Coefficients

    static member AreCompatible (p : Polynomial<'T>, q : Polynomial<'T>) =
        p.X = q.X && p.Ys = q.Ys || p.IsConstant || q.IsConstant

    static member Compatibleness (p : Polynomial<'T>, q : Polynomial<'T>) =
        if not (Polynomial.AreCompatible (p, q)) then
            invalidArg "q" "Polynomial p and q are incompatible"
        Contract.EndContractBlock ()
        if p.IsConstant then
            q.X, q.Ys, q.F, q.G
        else
            p.X, p.Ys, p.F, p.G

    static member (+) (p : Polynomial<'T>, q : Polynomial<'T>) =
        if not (Polynomial.AreCompatible (p, q)) then
            invalidArg "q" "Polynomial p and q are incompatible"
        Contract.EndContractBlock ()
        let x, y, f, g = Polynomial.Compatibleness (p, q)
        Polynomial.Create (x, y, f, g, add (p.Coefficients, q.Coefficients))

    static member (*) (scalingFactor : int64, p : Polynomial<'T>) =
        let mapper f (t : 'T) =
            ((t :> ICoefficient).Scale64 f) :?> 'T
        Polynomial.Create (p.X, p.Ys, p.F, p.G, List.map (mapper scalingFactor) p.Coefficients)

    static member (*) (p : Polynomial<'T>, q : Polynomial<'T>) =
        if not (Polynomial.AreCompatible (p, q)) then
            invalidArg "q" "Polynomial p and q are incompatible"
        Contract.EndContractBlock ()
        let rec multiply (cs : 'T list, ds : 'T list) =
            match cs with
                | [] ->
                    List.empty
                | h :: ts ->
                    let multiplyTerm g d =
                        downcast ((g :> ICoefficient).Multiply d)
                    add (List.map (multiplyTerm h) ds, shiftRank 1 (multiply (ts, ds)))
        let x, y, f, g = Polynomial.Compatibleness (p, q)
        Polynomial.Create (x, y, f, g, multiply (p.Coefficients, q.Coefficients))

    member __.IsNegative =
        match exactlyOneNonZero __.Coefficients with
            | Some c ->
                (c :> ICoefficient).IsNegative
            | None ->
                false

    member __.IsZero =
        List.isEmpty __.Coefficients

    member __.Rank =
        List.length coefficients - 1

    member __.IsMonomial =
        Option.isSome (exactlyOneNonZero __.Coefficients)

    static member (~-) (p : Polynomial<'T>) =
        -1L * p

    member __.YsString =
        match __.Ys with
            | None ->
                String.Empty
            | Some zs ->
                let separator = ","
                sprintf "(%s)" (String.Join (separator, zs))

    override __.ToString () =
        if __.IsZero then
            "0"
        else
            let PolynomialTerms = seq {
                for k = __.Rank downto 0 do
                    let d = List.item k __.Coefficients
                    if not (isZero d) then
                        yield (k = __.Rank), (k = 0), k, d
            }
            let stringBuilder = StringBuilder ()
            for fi, eo, p, c in PolynomialTerms do
                let t = c.CoefficientString (fi, eo)
                ignore (stringBuilder.Append t)
                if p <> 0 then
                    if not (String.IsNullOrEmpty t) &&
                            t <> "-" && not (t.EndsWith " ") then
                        ignore (stringBuilder.Append " ")
                    ignore (stringBuilder.Append __.X)
                    if p <> 1 then
                        ignore (stringBuilder.Append (sprintf "^%d" p))
                    ignore (stringBuilder.Append __.YsString)
            stringBuilder.ToString ()

    member __.CoefficientString (first : bool, explicitOne : bool) =
        if explicitOne || (not __.IsOne && not (-__).IsOne) then
            if __.IsZero || __.IsMonomial then
                if __.IsNegative then
                    if first then
                        sprintf "-%s" ((-__).ToString ())
                    else
                        sprintf " - %s" ((-__).ToString ())
                else
                    if first then
                        sprintf "%s" (__.ToString ())
                    else
                        sprintf " + %s" (__.ToString ())
            else
                if first then
                    if explicitOne then
                        __.ToString ()
                    else
                        sprintf "(%s)" (__.ToString ())
                else
                    sprintf " + (%s)" (__.ToString ())
        else
            if __.IsOne then
                if first then
                    String.Empty
                else
                    " + "
            else
                if first then
                    "-"
                else
                    " - "

    member __.Apply (m : Map<string, float>) =
        if __.IsZero then
            0.0
        elif __.IsConstant then
            (List.exactlyOne __.Coefficients :> ICoefficient).Apply m
        else
            let mapper u a (i : int) c =
                ((c :> ICoefficient).Apply a) * Math.Pow (u, float i)
            let v =
                match Map.tryFind __.X m with
                    | None ->
                        (Option.get f) __.Ys m
                    | Some w ->
                        w
            Seq.sum (Seq.mapi (mapper v m) __.Coefficients)

    member __.ApplyComplex (m : Map<string, Complex>) =
        if __.IsZero then
            Complex.Zero
        elif __.IsConstant then
            (List.exactlyOne __.Coefficients :> ICoefficient).ApplyComplex m
        else
            let seqAddComplex (zs : Complex seq) =
                Seq.fold (+) Complex.Zero zs
            let mapper u a (i : int) c =
                ((c :> ICoefficient).ApplyComplex a) * Complex.Pow (u, float i)
            let v =
                match Map.tryFind __.X m with
                    | None ->
                        (Option.get g) __.Ys m
                    | Some w ->
                        w
            seqAddComplex (Seq.mapi (mapper v m) __.Coefficients)

    interface ICoefficient with
        member __.Zero =
            upcast Polynomial<'T>.Zero
        member __.IsOne =
            __.IsOne
        member __.Add (t : ICoefficient) =
            upcast (__ + downcast t)
        member __.Scale64 (scalingFactor : int64) =
            upcast (scalingFactor * __)
        member __.Multiply (t : ICoefficient) =
            upcast (__ * downcast t)
        member __.IsNegative =
            __.IsNegative
        member __.CoefficientString (first : bool, explicitOne : bool) =
            __.CoefficientString (first, explicitOne)
        member __.Apply (m : Map<string, float>) =
            __.Apply m
        member __.ApplyComplex (m : Map<string, Complex>) =
            __.ApplyComplex m

    static member (-) (p : Polynomial<'T>, q : Polynomial<'T>) =
        p + (-q)

    static member (<<<) (p : Polynomial<'T>, k : int) =
        if p.IsConstant && not (p.IsZero) && k > 0 then
            invalidArg "k" ("Cannot shift rank of non-zero constant polynomial" +
                " (as constant polynomials have no variable)")
        Polynomial.Create (p.X, p.Ys, p.F, p.G, shiftRank k p.Coefficients)

    static member (>>>) (p : Polynomial<'T>, k : int) =
        p <<< -k

    member __.Derivative =
        if __.IsConstant then
            Polynomial<'T>.Zero
        else
            let mapper p (t : 'T) =
                (t :> ICoefficient).Scale64 (int64 p) :?> 'T
            let coefficients = List.mapi mapper __.Coefficients
            (Polynomial.Create (__.X, __.Ys, __.F, __.G, coefficients)) >>> 1

    static member Constant (t : 'T) =
        Polynomial<'T>.Create (String.Empty, None, None, None, [t])

    member __.HasOnlyEvenPowers =
        hasOnlyEvenIndexedItems __.Coefficients

    member __.HasOnlyOddPowers =
        hasOnlyOddIndexedItems __.Coefficients

    override __.GetHashCode () =
        __.Coefficients.GetHashCode () ^^^
            (__.X.GetHashCode () <<< 1) ^^^ (__.Ys.GetHashCode () <<< 2)

    member __.Equals (that : Polynomial<'T>) =
        __.X = that.X && __.Ys = that.Ys && __.Coefficients = that.Coefficients

    interface IEquatable<Polynomial<'T>> with
        member __.Equals (that : Polynomial<'T>) =
            __.Equals that

    override __.Equals (that : obj) =
        match that with
            | null ->
                false
            | :? Polynomial<'T> as thatPolynomial ->
                __.Equals thatPolynomial
            | _ ->
                false

    static member op_Equality (p : Polynomial<'T>, q : Polynomial<'T>) =
        p.Equals q

    static member op_Inequality (p : Polynomial<'T>, q : Polynomial<'T>) =
        not (Polynomial.op_Equality (p, q))

module PolynomialsTrig =

    let singleVariableFunction (h : float -> float) (ys : string list option) (m : Map<string, float>) =
        h (Map.find (List.head (Option.get ys)) m)

    let singleVariableFunctionComplex (h : Complex -> Complex) (ys : string list option)
            (m : Map<string, Complex>) =
        h (Map.find (List.head (Option.get ys)) m)

    let rec derivativeSinPowerPolynomialInCos (k : uint32) =
        let one = Polynomial.Constant Coefficient64.One
        if k = 0u then
            Polynomial.Constant one
        else
            let n = "n"
            let x = "cos"
            let ys = Some ["x"]
            let f = Some (singleVariableFunction Math.Cos)
            let g = Some (singleVariableFunctionComplex Complex.Cos)
            let zero = Polynomial<Coefficient64>.Zero
            let minusOne = Polynomial.Constant Coefficient64.MinusOne
            let p (j : uint32) =
                let oneMinusJ = Coefficient64 (1L - int64 j)
                let nPlusOneMinusJ = Polynomial (n, None, None, None, [oneMinusJ; Coefficient64.One])
                Polynomial (x, ys, f, g, [zero; nPlusOneMinusJ])
            let q = Polynomial (x, ys, f, g, [minusOne; zero; one])
            let previousPolynomial = derivativeSinPowerPolynomialInCos (k - 1u)
            p k * previousPolynomial + q * previousPolynomial.Derivative

    let derivativeSinPowerPolynomialInSin (k : uint32) =
        let derivativeSinPowerPolynomialInSinFromPolynomialInCos
                (p : Polynomial<Polynomial<Coefficient64>>) =
            if not p.HasOnlyEvenPowers then
                invalidArg "p" "Polynomial p has at least one odd power"
            elif not (p.X = "cos" && Option.isSome p.Ys || p.IsConstant) then
                invalidArg "p" "Polynomial p is not compatible with a polynomial in cos"
            Contract.EndContractBlock ()
            let mapper i t =
                let rec powerOfSinSquaredMinusOne n =
                    let one = Polynomial.Constant Coefficient64.One
                    if n = 0u then
                        Polynomial.Constant one
                    else
                        let x = "sin"
                        let ys = p.Ys
                        let f = Some (singleVariableFunction Math.Sin)
                        let g = Some (singleVariableFunctionComplex Complex.Sin)
                        let minusOne = Polynomial.Constant Coefficient64.MinusOne
                        let zero = Polynomial<Coefficient64>.Zero
                        let r = Polynomial (x, ys, f, g, [one; zero; minusOne])
                        if n = 1u then
                            r
                        else
                            r * powerOfSinSquaredMinusOne (n - 1u)
                (Polynomial.Constant t) * powerOfSinSquaredMinusOne ((uint32 i) / 2u)
            Seq.sum (Seq.mapi mapper p.Coefficients)
        let q =
            if k % 2u = 0u then
                derivativeSinPowerPolynomialInCos k
            else
                (derivativeSinPowerPolynomialInCos k) >>> 1
        derivativeSinPowerPolynomialInSinFromPolynomialInCos q

    let printDerivativeOfSin stream k =
        let cosOrEmpty =
            if k % 2u = 0u then
                String.Empty
            else
                " cos(x)"
        fprintfn stream "d^%d/dx^%d sin^n(x)" k k
        fprintfn stream " = sin^(n-%d)(x) [%A]" k (derivativeSinPowerPolynomialInCos k)
        if (k / 2u) % 2u = 0u then
            fprintfn stream " = sin^(n-%d)(x)%s [%A]" k cosOrEmpty (derivativeSinPowerPolynomialInSin k)
        else
            fprintfn stream " = -sin^(n-%d)(x)%s [%A]" k cosOrEmpty -(derivativeSinPowerPolynomialInSin k)
        if k = 0u then
            fprintfn stream " = sin^n(x)"

    let printDerivativesOfSinUpto stream (lastK : uint32) =
        fprintfn stream "Derivatives of sin^n(x)"
        fprintfn stream ""
        for k = 0 to int lastK do
            printDerivativeOfSin stream (uint32 k)

    let rec derivativeCosPowerPolynomialInSin (k : uint32) =
        let one = Polynomial.Constant Coefficient64.One
        if k = 0u then
            Polynomial.Constant one
        else
            let n = "n"
            let x = "sin"
            let ys = Some ["x"]
            let f = Some (singleVariableFunction Math.Cos)
            let g = Some (singleVariableFunctionComplex Complex.Cos)
            let zero = Polynomial<Coefficient64>.Zero
            let minusOne = Polynomial.Constant Coefficient64.MinusOne
            let p (j : uint32) =
                let oneMinusJ = Coefficient64 (1L - int64 j)
                let nPlusOneMinusJ = Polynomial (n, None, None, None, [oneMinusJ; Coefficient64.One])
                Polynomial (x, ys, f, g, [zero; nPlusOneMinusJ])
            let q = Polynomial (x, ys, f, g, [minusOne; zero; one])
            let previousPolynomial = derivativeCosPowerPolynomialInSin (k - 1u)
            -(p k * previousPolynomial + q * previousPolynomial.Derivative)

    let derivativeCosPowerPolynomialInCos (k : uint32) =
        let derivativeCosPowerPolynomialInCosFromPolynomialInSin
                (p : Polynomial<Polynomial<Coefficient64>>) =
            if not p.HasOnlyEvenPowers then
                invalidArg "p" "Polynomial p has at least one odd power"
            elif not (p.X = "sin" && Option.isSome p.Ys || p.IsConstant) then
                invalidArg "p" "Polynomial p is not compatible with a polynomial in cos"
            Contract.EndContractBlock ()
            let mapper i t =
                let rec powerOfCosSquaredMinusOne n =
                    let one = Polynomial.Constant Coefficient64.One
                    if n = 0u then
                        Polynomial.Constant one
                    else
                        let x = "cos"
                        let ys = p.Ys
                        let f = Some (singleVariableFunction Math.Sin)
                        let g = Some (singleVariableFunctionComplex Complex.Sin)
                        let minusOne = Polynomial.Constant Coefficient64.MinusOne
                        let zero = Polynomial<Coefficient64>.Zero
                        let r = Polynomial (x, ys, f, g, [one; zero; minusOne])
                        if n = 1u then
                            r
                        else
                            r * powerOfCosSquaredMinusOne (n - 1u)
                (Polynomial.Constant t) * powerOfCosSquaredMinusOne ((uint32 i) / 2u)
            Seq.sum (Seq.mapi mapper p.Coefficients)
        let q =
            if k % 2u = 0u then
                derivativeCosPowerPolynomialInSin k
            else
                (derivativeCosPowerPolynomialInSin k) >>> 1
        derivativeCosPowerPolynomialInCosFromPolynomialInSin q

    let printDerivativeOfCos stream k =
        let sinOrEmpty =
            if k % 2u = 0u then
                String.Empty
            else
                " sin(x)"
        fprintfn stream "d^%d/dx^%d cos^n(x)" k k
        if k % 2u = 0u then
            fprintfn stream " = cos^(n-%d)(x) [%A]" k (derivativeCosPowerPolynomialInSin k)
        else
            fprintfn stream " = -cos^(n-%d)(x) [%A]" k -(derivativeCosPowerPolynomialInSin k)
        if ((k + 1u) / 2u) % 2u = 0u then
            fprintfn stream " = cos^(n-%d)(x)%s [%A]" k sinOrEmpty (derivativeCosPowerPolynomialInCos k)
        else
            fprintfn stream " = -cos^(n-%d)(x)%s [%A]" k sinOrEmpty -(derivativeCosPowerPolynomialInCos k)
        if k = 0u then
            fprintfn stream " = cos^n(x)"

    let printDerivativesOfCosUpto stream (lastK : uint32) =
        fprintfn stream "Derivatives of cos^n(x)"
        fprintfn stream ""
        for k = 0 to int lastK do
            printDerivativeOfCos stream (uint32 k)

    let derivativeOfPowerOfSin k n x =
       let s = Math.Sin x
       let p = derivativeSinPowerPolynomialInSin k
       let m = Map.ofList ["sin", s; "n", float n]
       let a = Math.Pow (s, float (n - int k)) * p.Apply m
       if k % 2u = 0u then
           a
       else
           Math.Cos x * a

    let derivativeOfPowerOfSinComplex k n z =
       let s = Complex.Sin z
       let p = derivativeSinPowerPolynomialInSin k
       let m = Map.ofList ["sin", s; "n", Complex.ofInt32 n]
       let a = Complex.Pow (s, Complex.ofInt32 (n - int k)) * p.ApplyComplex m
       if k % 2u = 0u then
           a
       else
           Complex.Cos z * a

    let derivativeOfPowerOfCos k n x =
       let c = Math.Cos x
       let p = derivativeCosPowerPolynomialInCos k
       let m = Map.ofList ["cos", c; "n", float n]
       let a = Math.Pow (c, float (n - int k)) * p.Apply m
       if k % 2u = 0u then
           a
       else
           Math.Sin x * a

    let derivativeOfPowerOfCosComplex k n z =
       let c = Complex.Cos z
       let p = derivativeCosPowerPolynomialInCos k
       let m = Map.ofList ["cos", c; "n", Complex.ofInt32 n]
       let a = Complex.Pow (c, Complex.ofInt32 (n - int k)) * p.ApplyComplex m
       if k % 2u = 0u then
           a
       else
           Complex.Sin z * a

module Qi =

    // Feng Qi, Derivatives of tangent function and tangent numbers
    // https://arxiv.org/pdf/1202.1205.pdf
    // top of p. 12 top for sin, and halfway p. 11 for cos

    let private seqAddComplex (zs : Complex seq) =
        Seq.fold (+) Complex.Zero zs

    let derivativeOfPowerOfSin k n x =
        let term r m y q =
            let twoQMinusM = 2 * q - int m
            let factorFactor = IntegerMath.powerOfMinusOne q * int (IntegerMath.choose m (uint32 q))
            let factor = float (factorFactor * IntegerMath.power twoQMinusM r)
            let argument = float (r - m) * Math.PI / 2.0 + float twoQMinusM * y
            Complex (factor * Math.Cos argument, factor * Math.Sin argument)
        let ns = int n
        let powMinusOne = Complex.ofInt32 (IntegerMath.powerOfMinusOne ns)
        let denominator = Complex.ofInt32 (IntegerMath.power 2 n)
        powMinusOne * seqAddComplex (Seq.map (term k n x) {0 .. ns}) / denominator

    let derivativeOfPowerOfSinComplex k n z =
        let term r m y q =
            let twoQMinusM = 2 * q - int m
            let factorFactor = IntegerMath.powerOfMinusOne q * int (IntegerMath.choose m (uint32 q))
            let factor = Complex.ofInt32 (factorFactor * IntegerMath.power twoQMinusM r)
            let halfPi = Complex.ofFloat64 (Math.PI / 2.0)
            let argument = Complex.ofUInt32 (r - m) * halfPi + Complex.ofInt32 twoQMinusM * y
            factor * Complex.Cos argument + factor * Complex.Sin argument * Complex.ImaginaryOne
        let ns = int n
        let powMinusOne = Complex.ofInt32 (IntegerMath.powerOfMinusOne ns)
        let denominator = Complex.ofInt32 (IntegerMath.power 2 n)
        powMinusOne * seqAddComplex (Seq.map (term k n z) {0 .. ns}) / denominator

    let derivativeOfPowerOfCos k n x =
        let term r m y q =
            let twoQMinusM = 2 * q - int m
            let factor = float (int (IntegerMath.choose m (uint32 q)) * IntegerMath.power twoQMinusM r)
            let argument = float r * Math.PI / 2.0 + float twoQMinusM * y
            Complex (factor * Math.Cos argument, factor * Math.Sin argument)
        let ns = int n
        seqAddComplex (Seq.map (term k n x) {0 .. ns}) / (Complex.ofInt32 (IntegerMath.power 2 n))

    let derivativeOfPowerOfCosComplex k n z =
        let term r m y q =
            let twoQMinusM = 2 * q - int m
            let factorFactor = int (IntegerMath.choose m (uint32 q))
            let factor = Complex.ofInt32 (factorFactor * IntegerMath.power twoQMinusM r)
            let halfPi = Complex.ofFloat64 (Math.PI / 2.0)
            let argument = Complex.ofUInt32 r * halfPi + Complex.ofInt32 twoQMinusM * y
            factor * Complex.Cos argument + factor * Complex.Sin argument * Complex.ImaginaryOne
        let ns = int n
        seqAddComplex (Seq.map (term k n z) {0 .. ns}) / (Complex.ofInt32 (IntegerMath.power 2 n))

module Polynomials =

    let derivativeOfPowerOfSin stream k n x =
        let z = Complex.ofFloat64 x
        fprintfn stream "d^%d/dx^%d sin^%d(x) | x = %s" k k n (x.ToString "R")
        fprintfn stream " = %s" ((PolynomialsTrig.derivativeOfPowerOfSin k n x).ToString "R")
        fprintfn stream " = %O" (PolynomialsTrig.derivativeOfPowerOfSinComplex k n z)
        fprintfn stream " = %O" (Qi.derivativeOfPowerOfSin k (uint32 n) x)
        fprintfn stream " = %O" (Qi.derivativeOfPowerOfSinComplex k (uint32 n) z)

    let derivativeOfPowerOfCos stream k n x =
        let z = Complex.ofFloat64 x
        fprintfn stream "d^%d/dx^%d cos^%d(x) | x = %f" k k n x
        fprintfn stream " = %s" ((PolynomialsTrig.derivativeOfPowerOfCos k n x).ToString "R")
        fprintfn stream " = %O" (PolynomialsTrig.derivativeOfPowerOfCosComplex k n z)
        fprintfn stream " = %O" (Qi.derivativeOfPowerOfCos k (uint32 n) x)
        fprintfn stream " = %O" (Qi.derivativeOfPowerOfCosComplex k (uint32 n) z)

    [<EntryPoint>]
    let main _args =
        let lastK = 10u
        let stream = Console.Out
        PolynomialsTrig.printDerivativesOfSinUpto stream lastK
        fprintfn stream ""
        PolynomialsTrig.printDerivativesOfCosUpto stream lastK
        fprintfn stream ""
        derivativeOfPowerOfSin stream 0u 1 (3.0 * Math.PI / 4.0)
        fprintfn stream ""
        derivativeOfPowerOfCos stream 0u 1 (3.0 * Math.PI / 4.0)
        fprintfn stream ""
        derivativeOfPowerOfSin stream 0u 1 (3.0 * Math.PI / 2.0)
        fprintfn stream ""
        derivativeOfPowerOfCos stream 0u 1 (3.0 * Math.PI / 2.0)
        ignore (Console.ReadKey ())
        0